PARSER_BEGIN(G2)
package model.initialisation;
import java.util.ArrayList;
import model.*;
import java.io.InputStream;
public class G2 {
	public static void main(String args[]) throws ParseException {
		G2 parser = new G2(System.in);
		Configuration.rules = new RulesConfiguration();
		parser.Rule();
	}
public static void readRules(InputStream stream) throws ParseException {
	G2 parser = new G2(stream);
	parser.RuleList();
}
	public static Expression readExpression(InputStream stream) throws ParseException {
		G2.ReInit(stream);
		Expression expression = Terme0();
		return new UnaryExpression("ROOT", expression);
	}
}

PARSER_END(G2)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}
TOKEN :
{
  < OR_OP : "|" >
| < AND_OP : "&" >
| < SUPEGAL_OP : ">=" >
| < INFEGAL_OP : "<=" >
| < SUP_OP : ">" >
| < INF_OP : "<" >
| < DIFF_OP : "!=" >
| < EGAL_OP : "=" >
| < MOINS_B_OP : "-" >
| < PLUS_OP : "+" >
| < DIVISER_OP : "/" >
| < FOIS_OP : "*" >
| < POWER_OP : "^" >
| < SQRT_LEFT : "sqrt" >
| < NOT_LEFT : "!" >
| < ROOT_LEFT : "#" >
| < PARENTHESIS_LEFT : "(" >
| < PARENTHESIS_RIGHT : ")" >
| < BRACKETS_LEFT : "{" >
| < BRACKETS_RIGHT : "}" >
| < LITTERAL : (["a"-"z"])+ >
| < ZERO : "0" >
| < UN : "1" >
| < EXPRESSION : ["A"-"Z"] >
| < RULE_INPUT_TYPE : "ยง" (["a"-"z","A"-"Z","_", "-"])+ >
| < LEFT_RULE_EQUIVALENT : "<=(" >
| < LEFT_RULE_NOT_EQUIVALENT : "=(" >
| < RIGHT_RULE : ")=>" >
}

Expression Epsilon() : { } { {return null;} }

void RuleList() :
{}
{
	( Rule() ) *
	<EOF>
}
void Rule() :
{
	Expression exp1;
}
{
	exp1 = Terme0()
	RuleBis(exp1)
}
void RuleBis(Expression exp1) :
{
	Expression exp2;
	Token input_type_rule;
}
{
	(
		<LEFT_RULE_EQUIVALENT>
		input_type_rule = <RULE_INPUT_TYPE>
		<RIGHT_RULE>
		exp2 = Terme0()
		{Configuration.rules.addRule(input_type_rule.image.substring(1), new Rule(exp1, exp2));   
		Configuration.rules.addRule(input_type_rule.image.substring(1), new Rule(exp2, exp1));   
		System.out.println(Configuration.rules.getRules());}
	) |
	(
		<LEFT_RULE_NOT_EQUIVALENT>
		input_type_rule = <RULE_INPUT_TYPE>
		<RIGHT_RULE>
		exp2 = Terme0()
		{Configuration.rules.addRule(input_type_rule.image.substring(1), new Rule(exp1, exp2));}
	)
}
void Axiome() :
{
	Expression exp;
}
{
	exp = Terme0()
	<EOF>

	{System.out.println(exp.expressionToString());}
}
Expression Terme0() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme1()
		exp2 = Terme0Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme0Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <OR_OP>
		exp1 = Terme0()
		{return new BinaryExpression("OR", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme1() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme2()
		exp2 = Terme1Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme1Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <AND_OP>
		exp1 = Terme1()
		{return new BinaryExpression("AND", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme2() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme3()
		exp2 = Terme2Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme2Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <SUPEGAL_OP>
		exp1 = Terme2()
		{return new BinaryExpression("SUPEGAL", exp, exp1); }
	)
	|
	(
		symbol = <INFEGAL_OP>
		exp1 = Terme2()
		{return new BinaryExpression("INFEGAL", exp, exp1); }
	)
	|
	(
		symbol = <SUP_OP>
		exp1 = Terme2()
		{return new BinaryExpression("SUP", exp, exp1); }
	)
	|
	(
		symbol = <INF_OP>
		exp1 = Terme2()
		{return new BinaryExpression("INF", exp, exp1); }
	)
	|
	(
		symbol = <DIFF_OP>
		exp1 = Terme2()
		{return new BinaryExpression("DIFF", exp, exp1); }
	)
	|
	(
		symbol = <EGAL_OP>
		exp1 = Terme2()
		{return new BinaryExpression("EGAL", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme3() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme4()
		exp2 = Terme3Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme3Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <MOINS_B_OP>
		exp1 = Terme3()
		{return new BinaryExpression("MOINS_B", exp, exp1); }
	)
	|
	(
		symbol = <PLUS_OP>
		exp1 = Terme3()
		{return new BinaryExpression("PLUS", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme4() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme5()
		exp2 = Terme4Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme4Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <DIVISER_OP>
		exp1 = Terme4()
		{return new BinaryExpression("DIVISER", exp, exp1); }
	)
	|
	(
		symbol = <FOIS_OP>
		exp1 = Terme4()
		{return new BinaryExpression("FOIS", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme5() :
{
		Expression exp;
		Expression exp2;
}
{
		exp = Terme6()
		exp2 = Terme5Bis(exp)

		{ return exp2 == null ? exp : exp2;}
}
Expression Terme5Bis(Expression exp) :
{
	Token symbol;
	Expression exp1;
}
{
	(
		symbol = <POWER_OP>
		exp1 = Terme5()
		{return new BinaryExpression("POWER", exp, exp1); }
	)
	|
	(
		exp1 = Epsilon()
		{return exp1;}
	)
}
Expression Terme6() :
{
	Token symbol;
	Expression exp;
}
{
	(
		symbol = <SQRT_LEFT>
		exp = Terme6()
		{return new UnaryExpression("SQRT", exp);}
	)
	|
	(
		symbol = <MOINS_B_OP>
		exp = Terme6()
		{return new UnaryExpression("MOINS_U", exp);}
	)
	|
	(
		symbol = <NOT_LEFT>
		exp = Terme6()
		{return new UnaryExpression("NOT", exp);}
	)
	|
	(
		symbol = <ROOT_LEFT>
		exp = Terme6()
		{return new UnaryExpression("ROOT", exp);}
	)
	|
	(
		exp = UnaireDroit()
		{return exp;}
	)
}
Expression UnaireDroit() :
{
	Expression primaire;
	Expression exp;

}
{
	primaire = Primaire()
	exp = UnaireDroitBis(primaire)
	{if(exp == null) return primaire; return exp;}
}
Expression UnaireDroitBis(Expression exp) :
{
	Token symbol;
	Expression exp2;
	Expression exp3;
}
{
	(
		symbol = <NOT_LEFT>
		{ exp2 = new UnaryExpression("FACTORIAL",exp);}
		exp3 = UnaireDroitBis(exp2)
		{return exp3 == null ? exp2 : exp3;}
	)
	|
	(
		exp2 = Epsilon()
		{return exp2;}
	)
}
Expression Primaire() :
{
	Token symbolLeft;
	Token symbolRight;
	Expression expression;
}
{
	(
		symbolLeft = <PARENTHESIS_LEFT>
		expression = Terme0()
		symbolRight = <PARENTHESIS_RIGHT>
		{return new UnaryExpression("PARENTHESIS",expression);}

	)
	|
	(
		symbolLeft = <BRACKETS_LEFT>
		expression = Terme0()
		symbolRight = <BRACKETS_RIGHT>
		{return expression;}

	)
	|
	(
		symbolLeft = <LITTERAL>
		{return new PrimaryExpression("LITTERAL",symbolLeft.image);}
	)
	|
	(
		symbolLeft = <ZERO>
		{return new PrimaryExpression("ZERO",symbolLeft.image);}
	)
	|
	(
		symbolLeft = <UN>
		{return new PrimaryExpression("UN",symbolLeft.image);}
	)
	|
	(
		symbolLeft = <EXPRESSION>
		{return new PrimaryExpression("EXPRESSION",symbolLeft.image);}
	)
}
